***
### **引用计数算法**
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就+1，当引用失效时，计数器值就-1，任何时刻计数器为0的对象就是不可能再被使用的。
	引用计数算法的实现简单，判定效率高，但是它很难解决对象之间的相互循环引用的问题。例如：对象objA和objB都有字段instance，令objA.instance = objB及objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问到，但是因为他们互相引用着对方，导致其引用计数都不为0，于是GC收集器无法回收他们。

***
### **可达性分析算法**
通过一系列的被称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连接时，则证明此对象是不可用的。
	在java语言中，可作为GC Roots的对象包括下面几种：
1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中类静态属性引用的对象（static）
3. 方法区中常量引用的对象（例如String.intern()返回的对象）
4. 本地方法栈中JNI（即一般说的Native方法）引用的对象


***
### **引用**
如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用
	在jdk1.2之后，java对引用的概念进行了扩充，将引用分为：
- 强引用：指在程序代码中普遍存在，类似”Object obj = new Object()”这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
- 软引用：描述一些还有用但非必须的对象。在系统要发生内存溢出之前，将会把这些对象列进回收范围之中进行第二次回收，如果还是没有足够的内存才会抛出OOM，在jdk1.2之后提供了SoftReference类来实现软引用
- 弱引用：被弱引用关联的对象只能生存到下一次GC之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉该对象，在jdk1.2之后提供了WeakReference类来实现弱引用
- 虚引用：一个对象是否有虚引用的存在完全不会对其生存时间构成影响，设置虚引用的目的是为了在收集的时候收到一个系统通知。在jdk1.2之后提供了PhantomReference类来实现虚引用

***
### **finalize()方法**
```java
	public class FinalizeEscapeGC {
	public static FinalizeEscapeGC SAVE_HOOK = null;
	public void isAlive() {
		System.out.println("i am alive");
	}
	@Override
	protected void finalize() throws Throwable {
		// TODO Auto-generated method stub
		super.finalize();
		System.out.println("finalize method excuted");
		SAVE_HOOK = this;
	}
	public static void main(String[] args) throws Throwable {
		SAVE_HOOK = new FinalizeEscapeGC();
		
		//对象第一次拯救自己
		SAVE_HOOK = null;
		System.gc();
		//因为finalize()方法优先级很低，所以等待0.5s
		Thread.sleep(500);
		if(SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("i am dead");
		}
		
		//这一次自救失败
		SAVE_HOOK = null;
		System.gc();
		//因为finalize()方法优先级很低，所以等待0.5s
		Thread.sleep(500);
		if(SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("i am dead");
		}
	}
}
```

运行结果：
finalize method excuted
i am alive
i am dead

如果对象在可达性分析中发现没有与GC Roots相连接的链，他会被标记并且被筛选，筛选的条件是这个对象是否覆盖了finalize()方法并且没有被调用过，这个对象就会被放置在一个叫做F-Queue的队列中，并且稍后由一个虚拟机建立的，低优先级的Finalizer线程去执行它，但并不承诺会等待它运行结束，这是因为如果一个对象在finalize()方法执行缓慢或者发生了死循环将会导致F-Queue队列中的其他对象等待，甚至导致内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那么在第二次标记时它将被移除出“即将回收”的集合.
这个方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不建议大家使用这个方法。

***
### **回收方法区**
方法区（HotSpot虚拟机中的永生代）的垃圾收集分为两部分:
1.	废弃常量：假如一个字符串进入了常量池中，但是当前系统没有任何地方引用了这个对象，如果这时发生内存回收，而且必要的话，这个常量就会被系统清理出常量池。常量池中的其他类（接口），方法，字段的符号引用也如此
2.	无用的类：该类的所有实例都已经被回收，加载该类的ClassLoader已经被回收，该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。那么虚拟机就可以对其进行回收。在大量使用反射，动态代理，CGLib等ByteCode框架，动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永生代不会溢出。

***
### **垃圾收集算法**
1.	标记-清除算法：首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它有两个不足：①效率问题，标记和清除两个过程效率都不高；②空间问题，标记清除之后会产生大量不连续的内存碎片
2.	复制算法：它将可用的内存分为了大小相等的两块，每次只使用其中的一块，当这一块用完了，就将还存活的对象复制到另外一块去上面，然后再把已经使用过的内存空间一次清理掉，这样对整个半区进行内存回收，内存分配时就不必考虑内存碎片等复杂情况，只要移动堆顶指针，顺序分配内存即可，实现简单，运行高效，但是代价是将内存缩小为原来的一半。
现在的商业虚拟机都采用这种收集算法来回收新生代，因为新生代的对象98%都是“朝生夕死”，所以将内存分为一块较大的Eden空间和两块较小Survivor空间，每次使用一块Survivor和一块Eden空间，回收时，将存活着的对象一次性复制到另外一块Survivor空间，如果另外一块Survivor空间没有足够的空间，那么这些对象将直接进入老年代。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1
3.	标记-整理算法：复制算法在对象存活率较高时就需要进行较多的复制操作，效率会变低，而且浪费空间，所以一般在老年代不能直接选用这种算法。
标记整理算法不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。
4.	分代收集算法：根据对象的存活周期的不同将内存划分为几块。一般把java堆分为新生代和老年代，在新生代选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，在老年代因为对象存活率高，没有额外空间对其进行担保，就必须选用标记-清除或者标记-整理算法。虚拟机给每个对象定义一个对象年龄计数器，每当对象在Survivor区中熬过一次MinorGC，年龄就+1，等到年龄到了阈值（默认为15）之后就会被晋升为老年代。当然并不一定都是这样的，如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代

***
### **HotSpot的算法实现**
1.	枚举根节点：可作为GC Roots的结点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百M，如果要逐一检查这里面的引用会消耗很多时间，在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中那些位置是引用，这样在GC扫描的时候就可以直接得知这些信息了。
2.	安全点：HotSpot没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都停顿下来开始GC，只有到达到安全点时才能暂停。
对于安全点，另一个需要考虑的问题是如何让所有线程都到最近的安全点进行停顿。这里有两种方式：①抢先式中断：在发生GC是，首先把所有线程都中断，如果有的线程不在安全点，就恢复线程，现在几乎没有采用抢先式中断的虚拟机。②主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，如果发现中断标志为真就自己中断挂起。
3.	安全区域：在一段代码片段中，引用关系不会发生变化，在这个区域的任何地方开始GC都是安全的。我们也可以把安全区域看做是被扩展了的安全点


***
### **垃圾收集器**
1.	.Serial收集器
这个收集器是一单线程的收集器，他在进行垃圾收集时候必须暂停其他所有的工作线程，直到它收集结束
2.	ParNew收集器
是Serial收集器的多线程版本，新生代收集器，只有这个收集器可以与CMS收集器配合工作
3.	Parallel Scavenge收集器
是一个新生代的收集器，使用的是复制算法，又是并行的多线程收集器，该收集器的关注点是达到一个可控制的吞吐量
4.	Serial Old收集器
是Serial收集器的老年代版本，使用标记-整理算法，单线程收集器
5.	Parallel Old收集器收集器
Parallel Scavenge老年代版本，标记-整理算法，多线程收集器
6.	CMS收集器
	是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法，它的运行过程分为4步：
	-	初始标记
	-	并发标记
	-	重新标记
	-	并发清除
	
	其中初始标记，重新标记需要暂停所有线程，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记是进行GC Tracing的过程，重新标记时为了修正并发标记期间因用户线程因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。并发标记和并发清理适合用户程序一起工作的。


	CMS的主要优点是：并发收集，低停顿，他还有三个明显的缺点：
	-	CMS对CPU资源非常铭感，在并发阶段，他虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。
	-	CMS无法处理浮动垃圾，由于在垃圾收集阶段用户程序还需要运行，所以需要预留足够的内存空间给用户线程使用，使用不能像其他收集器一样等到老年代几乎被填满了再进行收集。
	-	由于CMS是基于标记-清除算法实现的，因此会产生大量空间碎片产生导致给大对象分配内存带来麻烦
7.	G1收集器
	与其他收集器相比，G1具备以下特点：
	-	并行与并发
	-	分代收集
	-	空间整合：G1从整体上来看是基于标记-整理算法的实现的收集器，不会产生空间碎片
	-	可预测的停顿：G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。


	在使用G1收集器时，java堆的内存布局就已经与其他收集器有很大差别，它将整个java堆分为多个大小相等的独立区域，虽然还保留新生代和老年代的概念，但是新生代和老年代已经不再是物理隔离的，他们都是一部分Region的集合


	但是把java堆分成多个Region会产生另外一个问题：一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个java堆任意的对象发生引用关系，那样在做可达性分析的时候就得扫描整个java堆，当然还有其他的解决方法：虚拟机使用Remember Set来避免全堆扫描，G1中每个Region都有一个与之对应的Remember Set用来记录跨Region的引用关系。

