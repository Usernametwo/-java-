
***
### **运行时数据区域：**

    1. 程序计数器：线程私有，如果线程执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器的值为空（此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域）

    2. Java虚拟机栈：线程私有，生命周期与线程相同，每个java方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息，其中局部变量表存放了可知的各种基本数据类型，对象引用和returnAddress类型（指向了一条字节码指令的地址），局部变量表所需的空间在编译期间完成分配，在这个区域java虚拟机规定了两种异常状况：StackOverflowError异常和OutOfMamoryError异常

    3. 本地方法栈：为虚拟机使用到的Native方法服务，和虚拟机栈类似

    4. Java堆: java堆是java虚拟机管理的内存中最大的一块，被所有线程共享，存放对象实例，是垃圾收集器管理的主要区域，如果堆中没有内存完成实例分配，并且堆无法扩展时会抛出OutOfMemoryError异常

	5. 方法区：各个线程共享的区域，存放已被虚拟机加载的类信息，常量，静态变量以及即时编译器编译后的代码等数据，当方法区无法满足内存分配需求的时候会抛出OutOfMemoryError异常

	6. 运行时常量池：是方法区的一部分，Class文件除了有类的版本，字段，方法，接口等描述信息之外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池相对于Class文件常量池的一个重要特征是具备动态性，运行期间也可能将新的常量放入池中，比如String类的intern方法。

	7. 直接内存（不是虚拟机运行时数据区的一部分，也不是java虚拟机规范的内存区域）：jdk1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，他可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象来作为这块内存的引用进行操作。这样能避免java堆和Native堆中来回复制数据，提高了性能。该区域也会出现OutOfMemoryError异常


***

### **HotSpot虚拟机对象揭秘：**

	1. 对象的创建：虚拟机遇到new指令的时候，会检查这个指令的参数是否能在常量池(方法区)中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，如果没有则执行类加载过程类加载检查通过之后，为新对象从java堆分配内存（通过指针碰撞或者空闲列表的分配方式）。内存分配完成之后虚拟机需要将分配的内存空间都初始化为零值，接下来，虚拟机对对象进行必要的设置，比如这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息，将其存放在对象头中。执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个可用的对象才算真正产生出来。

	2. 对象的内存布局：在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头，实例数据，和对齐填充。对象头包含两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码，GC分代信息，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，如果对象是一个java数组，那么还需要记录数组的长度。接下来的实例数据部分是真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的。第三部分对其填充没有特别的含义，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也即对象的大小必须是8字节的整数倍，所以需要对齐填充来补全。

	3. 对象的访问定位：Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置。目前主流的访问方式有使用句柄和直接指针两种
	- 如果使用句柄来访问的话，java堆会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄包含对象实例数据（存储在java堆）和类型数据（存储在方法区）各自的地址信息
	- 如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息

***
### **示例：**
String.intern()方法是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回这个对象。否则，将此对象包含的字符串添加到常量池中，并且返回这个对象的引用。
```java
public class RuntimeConstantPoolOOM {
	public static void main(String[] args) {
		String string1 = new StringBuilder("计算机").append("软件").toString();
		System.out.println(string1.intern() == string1);
		
		String string2 = new StringBuilder("ja").append("va").toString();
		System.out.println(string2.intern() == string2);
	}
}
```
这段代码在jdk1.6中运行，会得到两个false，而在jdk1.7中运行，会得到一个true和一个false。产生差异的原因是：在jdk1.6中，intern()方法会把首次遇到的字符串实例复制到永生代中，返回的也是永生代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在java堆上，所以必然不是同一个引用，将返回false。而jdk1.7的intern()不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对string2比较返回false是因为”java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有他的引用，而”计算机软件”这个字符串是首次出现的。

关于hotspot的永久代（方法区）变成了元空间
移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。
