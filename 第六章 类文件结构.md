***
### **虚拟机的语言无关性**
Java虚拟机不和包括java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但是任一门功能性语言都可以表示为一个能被java虚拟机所接受的有效的Class文件。作为一个通用的，机器无关的执行平台，任何其他语言的实现者都可以将java虚拟机作为语言的产品交付媒介。虚拟机并不关心Class的来源是何种语言。

***
### **Class类文件的结构**
任何一个Class文件都对应着唯一一个类或接口的定义信息，但是类或者接口并不一定都得定义在文件里（例如类或者接口也可以通过类加载器直接生成）。


根据java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的微结构来存储数据，这种伪结构包含两种数据类型：
- 无符号数：无符号数属于基本的数据类型，以u1,u2,u4,u8来分别表示一个字节，两个字节，四个字节和八个字节的无符号数，无符号数可以用来描述数字，索引引用，数值量或者按照UTF-8编码构成的字符串值
- 表：表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表用于描述有层次关系的复合结构的数据，比如常量池，属性，方法等


Class的结构不像XML等描述语言，由于他没有任何分隔符号，所以其数据项的顺序和数量，甚至是数据存储的字节序，都是被严格限定的


1.魔数（4个字节）


每个Class文件的头四个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，固定为：0xCAFEBABE

2.Class文件的版本(4个字节)


高版本的JDK可以向下兼容以前版本的Class文件，但不能运行以后版本的Class文件

3.常量池


由于常量池中的常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值。在Class文件格式规范制定之时，设计者将第0项常量空了出来用来表示“不引用任何一个常量池项目”的含义。


常量池中主要存放两大类常量：
- 字面量：如文本字符串，声明为final的常量值等
- 符号引用：类和接口的全限定名，字段名称和描述符，方法的名称和描述符

4.访问标志（两个字节）


用于标志一些类或者接口层次的访问信息，包括：这个Class是类或者是接口，是否为public，是否为abstract，final等等


5.类索引（两字节）


确定这个类的全限定名，u2类型的数据，记录的是指向常量池的索引


6.父类索引（2字节）


父类的全限定名，u2类型数据，记录的是常量池的索引


类索引和父类索引各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串（例如org/fenixoft/clazz/TestClass）。

7.接口索引集合


u2类型的数据的集合，入口的第一项为u2类型的接口计数器，后面为u2类型的接口索引表



8.字段表集合


用于描述借口或者类中声明的变量，字段包括类级变量以及实例变量，但不包括方法内部声明的局部变量。描述的信息有：字段的作用域（public，private，protected），static，final，volatile，transient，字段数据类型，字段名称，其中字段名称和数据类型只能引用常量池中的常量来描述。字段表中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本java代码中不存在的字段，譬如为了保持对外部类的访问性，会自动添加指向外部类实例的字段。


在java语言中字段是无法被重载的，两个字段的数据类型，修饰符不管是不是相同，都必须使用不一样的名称，但是对于字节码来说，如果两个字段的描述符不一样，字段重名是合法的


9.方法表集合


Class文件存储格式中队方法的描述与对字段的描述几乎采用了完全一致的方式，包括访问标志，名称索引，描述符索引（描述字段的数据类型，方法的参数列表（包括数量，类型以及顺序）和返回值），属性表集合。


方法里面的java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。
	

与字段表集合相对应的，如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。在java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与眼方法不同的特征签名，特征签名就是一个方法中的各个参数在常量池中的字段符号引用的集合，但是不包含返回值，因此java无法仅仅依靠返回值的不同来对一个已有方法进行重载。但是在Class文件中特征签名的范围更大（还包括返回值以及受查异常表），只要描述符不是完全一致的两个方法也可以共存。

10.属性表集合


属性表集合的限制宽松一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息。

- Code属性：
属性名称，属性值的长度，操作数栈深度的最大值，局部变量表所需的存储空间以及字节码长度和字节码指令（每个指令是一个u1类型的单字节），java虚拟机执行字节码是基于栈的体系结构。(在任何实例方法里，都可以通过this关键字来访问到此方法所属的对象，是通过javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后再虚拟机调用实例方法的时候自动传入此参数，因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量)
在字节码指令之后的是这个方法的显式异常处理表集合，异常表对Code属性来说不是必须存在的，异常表包括四个字段：如果当字节码在第start_pc行到第end_pc行之间（不含end_pc）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type为0的时候，代表任意异常情况都需要转到handle_pc处进行处理。
```java
public class Main{
		public static int method() {
			int y;
			try {
				y = 0;
				return y;
			} catch (Exception e) {
				// TODO: handle exception
				y = 1;
				return y;
			} finally {
				y = 2;
			}
		}
		public static void main(String[] args) {
			System.out.println(Main.method());
		}
}
```
    这段代码的结果为0
    代码分析： return语句会被解析为两个指令（Tload和Treturn）, iload会将y的值复制一份副本到最后一个本地变量表的slot中（returnValue），ireturn会返回操作栈顶中的值。catch中的语句会在发生异常的时候执行，而finally里面的语句不管发不发生异常都会在Tload指令执行之后之后执行,执行完毕之后将之前保存在returnValue中的数读入到操作栈顶。所以会返回0，而不是2。
-	Exception属性
这里的Exception属性是在 方法表中与Code属性平级的一个属性，和前面的Code属性里面的异常表有区别，Exceptions属性的作用是列举出方法中可能抛出的受查异常，也就是throws关键字后面列举的异常
- LineNumberTable：描述java源码行号与字节码行号之间的对应关系，非必须
- LocalVariableTable属性：描述栈帧中局部变量表中的变量与java源码中定义的变量的关系，非必须
- SourceFile属性：记录源文件名称，非必须
- ConstantValue属性：通知虚拟机自动为静态变量赋值
- InnerClasses属性：记录内部类与宿主类之间的关联
- Deprecated及Synthetic属性：Deprecated表示该类，字段，方法是否被@Deprecated修饰（bool值），Synthetic代表此字段或者方法不是由java源码直接产生，而是由编译器加上去的（bool值）
- StackMapTable属性:这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。
- Signature属性：记录泛型信息，因为java语言的泛型采用的是擦除法实现的伪泛型，在字节码中，泛型信息编译之后统统被擦除掉，现在java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。
- BootstrapMethods：保存invokeddynamic指令引用的引导方法限定符


***
### **字节码指令简介**
字节码指令集是一种具有鲜明特点，优劣势都很突出的指令集架构，由于限制了java虚拟机操作码的长度为1个字节，这意味着指令集的操作码数总数不能超过256条，又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中构建出具体数据的结构，如果要将一个16位长度的无符号整数使用两个无符号字节存储起来（将其命名为byte1和byte2），那么他们的值应该是这样的：
(byte1 << 8) | byte2
这种操作在某种程度上会导致解释执行字节码时损失一些性能。但这样做的优势也非常明显：省略很多填充和间隔符号，可以获得短小精干的编译代码
-	字节码与数据类型


    在java虚拟机指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如：iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload则是float数据，这两条指令的操作在虚拟机内部可能会有同一段代码来实现，但在Class文件中他们必须拥有各自独立的操作码。其中，i代表int，d代表double等等，需要注意的是a代表reference。。


    由于java虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力。所以大部分的指令都没有支持整数类型byte，char，short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展(Sign-Extend)为相应的int类型数据，将boolean和char类型数据零位扩展(Zero-Extend)为相应的int类型数据。
-   加载和存储指令：


    加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输
    + 将一个局部变量加载到操作栈：Tload,Tload_\<n\>(T代表i,l,f,d,a)
    + 将一个数值从操作数栈存储到局部变量表：Tstore,Tstore_\<n\>
    + 将一个常量加载到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_m1,iconst_\<i\>,lconst\<l\>,fconst\<f\>,dconst\<d\>
    + 扩充局部变量表的访问索引的指令：wide


-	运算指令：	


    运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
    + 加法指令：Tadd(T代表I,l,f,d)
    + 减法指令：Tsub
    + 乘法指令：Tmul
    + 除法指令：Tdiv
    + 求余指令：Trem
    + 取反指令：Tneg
    + 位移指令：ishl,ishr,iushr,lshl,lshr,lushr
    + 按位或指令：ior,lor
    + 按位与指令：iand,land
    + 按位异或指令：ixor,lxor
    + 局部变量自增指令：iinc
    + 比较指令：dcmpg,dcmpl,fcmpg,fcmpl,lcmp


    Java虚拟机规范没有明确规定过整数数据溢出的具体运算结果，仅规定了在处理整型数据时，只有除法指令(idiv,ldiv)以及求余指令(irem,lrem)中当出现除数为0时会导致虚拟机抛出ArithmeticException异常。Java虚拟机在处理浮点数运算时不会产生任何运行时异常，当产生异常时，会用NaN表示。


-   类型转换指令：


    将不同类型的数据进行相互转换。Java虚拟机直接支持（即转换时无需显式的转换指令）：
    + int转换到long,float,double
    + long转换到float，double
    + float转换到double


    进行窄化类型转换时，必须显式地使用转换指令来完成。这些转换指令包括：i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f。尽管数据转换时可能会发生上限溢出，下限溢出和精度丢失等问题，但是java虚拟机并不会抛出运行时异常。
-   对象创建与访问指令
    + 创建类实例的指令
    + 创建数组的指令
    + 访问类字段
    + 把一个数组元素加载到操作数栈的指令
    + 把一个操作数栈的值存储到数组元素中的指令
    + 取数组长度的指令
    + 检查类实例类型的指令
-   操作数栈管理指令
    +  将操作数栈的站定的一个或者两个元素出栈
    + 复制栈顶一个或者两个数值并将复制值或双份的复制值重新压入栈顶
    + 将栈最顶端的两个值互换
-   控制转移指令
    + 条件分支
    + 复合条件分支
    + 无条件分支
-   方法调用和返回指令
    + invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派
    + invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找到合适的方法并且调用
    + invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法
    + invokestatic调用类方法
    + invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。
    + 返回指令根据返回值的类型区分，Treturn(i,l,f,d,a)，还有一条return指令供生命为void,实例初始化方法以及类和接口的类初始化方法使用。
-   异常处理指令
    + athrow
-   同步指令


    Java虚拟机恶意支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程来实现的。


    方法级的同步是隐式的，即无需通过字节码指令来控制。虚拟机乐意从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知这个方法是否为同步方法，如果是的话就检查ACC_SYNCHRONIZED是否被设置，如果被设置了执行线程就要求先成功持有管程，然后才能执行方法，方法结束时释放管程，如果在方法执行期间抛出了异常，那么这个同步方法所持有的管程将在异常抛出同步方法之外时自动释放。


    同步一段指令集序列通常是由java语言中的sychronized语句块来表示的，java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持sychronized关键词的语义。



Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统），紧凑，稳定和可扩展的特点，是java技术体系实现平台无关，语言无关两项特性的重要支柱。
	
